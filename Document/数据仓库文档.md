# <center>数据仓库查询优化探究</center>

1651718 方沛	1650527 蔡震栋	1651701 魏楠	1651200浦家瑞  

## 一. 项目介绍

   针对电影及其周边信息，建立基于关系型数据仓库、分布式文件型数据仓库系统和图数据库的数据仓库系统，并进行系统性能比对

**要求:**

1. 能够从数据来源处获取数据，进行数据预处理

2. 建立关系型数据仓库存储模型，存储数据

3.  建立分布式文件系统存储模型，存储数据

4. 建立图数据库存储模型，存储数据

5. 在数据展现的界面上能够执行数据应用中的查询，并将在三种不同存储模型上的执行时间以数值的方式和图表的方式显示在界面上

6.  对每种存储方式结合本项目说明各自适用于处理什么查询，针对本项目在存储优化中做了什么工作，优化前后的比较结果是怎样的，以文档的方式提交
	

**数据来源：**Snap的文本文件和Amazon网站.

**数据包括但不限于以下信息:**

电影ID，评论用户ID，评论用户ProfileName，评论用户评价Helpfulness，评论用户Score，评论时间Time，评论结论Summary，评论结论Text，电影演员，电影上映时间，电影风格，电影导演，电影主演，电影演员，电影版本等信息。

## 二. 项目过程

### 2.1 ETL

#### 2.1.1 提取数据

1. 将Stanford的Snap的.txt文件读取并提取出ID号读取到csv文件中.

2. 根据ID号使用爬虫到亚马逊的对应页面爬取我们所需要的相关信息,在爬取的过程中同时使用`Beautiful Soup`模块进行页  面内容解析,提取出需要的内容,保存为json文件.

   内容样例:

   ```json
   {
       "ID": "B009NLADO0", 
       "Title": "The Golden Opportunity of Child Development Part 1", 
       "Intro": "A miraculous story for ...", 
       "IMDB": null, 
       "Score": 4.3, 
       "Year": 1997, 
       "Genre": ["Document"], 
       "Director": ["Ula Lubin", "Brad Lubin"], 
       "Starring": ["Ula Lubin", "Dr. Ilene Val-Essen", "Dr. Marjorie Rand", "Dr. Michael Levittan", "Dr. Joshua Wyner"], 
       "Supporting": ["John Erics"], 
       "Reviews": [
           {
           "Profile": "Natalya", 
           "Moment": {"Year": 2012, "Month": 11, "Day": 16}, 
           "Score": 5.0, 
           "Summary": "This DVD will change your perspective on parenting in general", 
           "Text": "I have 1 year old and throughout my pregnancy. Highly recommended.", 
           "Helpful": 2, 
           "Emotion": 0.49
           }
       ]
       "Emotion": 0.57
}
   ```
   
   

#### 2.1.2  分析数据

根据我们的项目要求,实现对电影基于情感倾向的分类,为了确定电影的情感倾向,我们分析了每部电影所对应的评论.通过从Open ML上的一个25000 条影评的二分类数据集训练Sequence Model 并对每一条影评进行回归分析. 以每条评论的Helpful数目进行加权平均得出电影的情感倾向.随后确定了我们基本的事实表和维度表.

#### 2.1.3 加载数据

项目要求我们是用到一种关系型数据库,一种分布式文件型数据库,一种图数据库.

根据查阅资料,我们选择了以下三种产品:

1. **关系型数据库: Mysql,**

   用于存储 电影的基本信息, 即所有与电影ID 有一对一关系的数据

2. **分布式文件型数据库:  MongoDB**

   由于在本项目中涉及到介绍,描述,类别,导演演员等长文档信息数目不确定的信息,因此我们使用到了MongoDB 存储类似的信息,可以提供和Mysql差不多的查询速度,在多维度查询中,使用MongoDB避免了使用关系型数据库的Join操作,在查询速度上有极大的优势.

3. **图数据库: Neo4j**

   在项目中要求对导演和演员的关系进行查询,包括和做关系和演员关系,在ETL过程中,我们发现所有电影共涉及38000多个导演和30多万导演,在关系的查询中无论是Mysql 和 MongoDB都显得无能为力,因此我们使用了Neo4j. 同时由于Neo4j 丰富了我们的存储方式,使得我们的星型模型得到简化

关系型数据库的ER图以及图数据库,分布式文档型数据库的表结构文件都在文件夹中.

### 2.2 展示页面构建

我们的展示页面主要分为两个分页,分别是**查询电影**和**查询关系**,其中**查询电影**可以搜索电影的**基本信息**和**详情信息**.

**基本信息**包括: 产品编号ID, 产品名字Title, 产品打分Score, 产品年份Year

**详情信息**包括: 以上所有 + 电影介绍Intro, 电影类别Genre, 电影导演Director, 电影演员Actor

**查询关系**包括: 指定目标类型(导演或演员),指定目标名字(支持模糊搜索), 查询关系目标(导演还是演员), 查询数目(查询和目标关系最密切的前几位.)

**实现的查询有:**

1. 按照时间进行查询及统计（指定两个年份,也可以只指定一个下限或上限）

2. 按照电影名称进行查询及统计（支持模糊查询查出所有版本）

3. 按照导演进行查询及统计（例如 XX导演共有多少电影,导演喜欢和哪些演员合作,合作几次,合作电影名）

4. 按照演员进行查询及统计（例如 XX演员共有多少电影,导演喜欢和哪些演员合作,合作几次,合作电影名）

5. 按照电影打分,情感倾向,类别等查询及统计

6. 按照电影类别进行查询及统计（例如 Action电影共有多少，Adventure电影共有多少等）

7. 使用以上选项综合筛选

**工具**:

​	前端: Vue + Echarts

​	后端: Flask

​	数据库: Mysql, MongoDB, Neo4j

​	数据库连接: SqlAlchemy, Pymongo, Neo4j Python Driver

**实验环境**:
Windows 10 单机
Hardware: Core i7 & 16 G 
Database: Mysql 8.0.13 Neo4j 3.5.13 MongoDB 4.0.7

在上课的时候老师已经提到了数据仓库中的反范式和冗余情况,所以在初步设计的时候我们直接放弃了全部由传统的关系型数据库的设计思想,适当的在冗余和遵守范式当中做出了折中. 并根据初步的查询情况进行进一步的优化.

## 三. 数据仓库设计和游湖

### 3.1 模型设计

#### 3.1.1 星型模型

雪花模型使用的是规范化数据，数据在数据库内部是组织好的，以便消除冗余，能够有效地减少数据量。通过引用完整性，其业务层级和维度都将存储在数据模型之中。相比较而言，星 形模型实用的是反规范化数据。在星形模型中，维度直接指的是事实表，业务层级不会通过维度之间的 参照完整性来部署。星型模型这样的存储方式，能够有效的减少各个表之间的join操作，适合我们这个项目对查询速度的需求。

基于电影基本信息的事实表,和其他各种统计的维度表,建立了如下的模型.

![](C:\Users\t470p\Desktop\数据仓库项目\报告\img\逻辑存储模型.jpg)

####  3.1.2 查询过程

实际查询中,我们做出了这样的选择:

1. 将所有与电影可能有一对多关系的放入MongoDB当中,作为电影的详情信息.同时保存了ID用于去Mysql寻找基本信息

2. 将不可能出现一对多关系的数据放入Mysql中作为基本信息

3. 将可能涉及导演,演员,评论人,电影的关系放入Neo4j中方便关系查询.

##### 3.1.2.1 查询基本信息

1. 判断筛选项里是否包含详情信息

   1) 如果没有,直接进入Mysql当中查询基本信息.

   2) 如果有,先去MongoDB中通过详情信息筛选ID,然后去Mysql查找基本信息
   
2. 后端整理并返回信息
   
##### 3.1.2.2 查询详情信息

1. 判断筛选项是否包含详情信息

   1) 没有,先去Mysql中查找符合条件的电影ID和基本信息返回后端,后端再用ID去MongoDB里查询详情信息并返回

   2) 有,评估详情信息筛选和基本信息筛选的优先级,决定先去Mysql还是MongoDB,分别返回数据.

2. 后端根据ID将数据拼接为详情返回前端

##### 3.1.2.3 查询关系

1. 根据模糊输入的人名匹配Neo4j的开始节点,
2. 遍历所有开始节点,分别寻找到 人物a $\rightarrow$  人物b $\rightarrow$ 电影m $\rightarrow$ 电影a的模式返回.

### 3.2 查询优化

#### 3.2.1 信息查询

1. 在查询**基本信息**当中, 如果筛选项有详情信息,始终先从MongoDB里搜索详情信息再去Mysql中寻找基本信息.因为如果先从Mysql当中用基本信息查询,会多一次数据层的访问.

2. 在查询**详情信息**时,在查找类别信息时我们先使用了Mysql的Join操作将类别表的信息返回.

   在一些极端情况下查询非常耗时,比如在一些关系型数据库无法建立索引的数据上

   最后我们采用了把Genres,Actors,Directors信息放入MongoDB中,通过MongoDB筛选,再通过建立索引优化.

   例: 设置Director搜索字段为"y",其余全为空的耗时
   
   | Mysql Join | MongoDB +Mysql | MongoDB+Mysql+索引 |
   | ---------- | -------------- | ------------------ |
   | > 6s       | 3.72 s         | 2.95 s             |
   
   

3. 在查询**详情信息**时,要分别执行Mysql 和 MongoDB,后执行的数据库一定有一个筛选条件时前一个数据库返回的id,因此这个中间id的数目直接决定了查询的速度,我们一开始是采取始终先查询MongoDB的选项,后来经过优化,会先判断详情筛选和基本信息筛选的比重,若基本筛选项能筛选出更多的id,则先去Mysql中查基本信息再去MongoDB查详情信息.这使得各种筛选条件下的查询时间比较稳定

#### 3.2.2 关系查询
1. 在查询**关系信息**时, 由于人名模糊匹配,起始节点不止一个,所以要先将起始节点先查询出来再用neo4j 一一查询,而第一步可以使用Mysql优化,在Mysql中分别增加一个演员表和一个导演表. 后来我们发现,通过在neo4j里给 actor 和 director 添加索引,在20w量级下,这一步查询时间相差大概在0.1s 区别不大

## 四. 分数分配

**人员:** 魏楠 蔡震栋 浦家瑞 方沛

**比例:**平分